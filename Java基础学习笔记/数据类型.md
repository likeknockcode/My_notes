# 数据类型

## 基本数据类型

- **四类八种**

  | 基本数据类型 | 分类   | 比特数 | 默认值       | 取值范围              | 说明                              |
  | ------------ | ------ | ------ | ------------ | --------------------- | --------------------------------- |
  | `boolean`    | 布尔型 | 8位    | `false`      | {true-false}          |                                   |
  | `char`       | 字符性 | 16位   | ``'/u0000'`` | {0 - 2^16-1}          | 存储Unicode码值，用单引号赋值     |
  | `byte`       | 整数型 | 8位    | `0`          | {-2^7 - 2^7-1}        |                                   |
  | `short`      | 整数型 | 16位   | `0`          | {-2^15 - 2^15-1}      |                                   |
  | `int`        | 整数型 | 32位   | `0`          | {-2^31 - 2^31-1}      |                                   |
  | `long`       | 整数型 | 64位   | `0L`         | {-2^63 - 2^63-1}      | 赋值时一般在数字后加上 `l` 或 `L` |
  | `float`      | 浮点型 | 32位   | ``+0.0F`     | {-2^-149 - 2^128-1}   | 赋值时必须在数字后加上 `f` 或 `F` |
  | `double`     | 浮点型 | 64位   | ``+0.0D`     | {-2^-1047 - 2^1024-1} | 赋值时一般在数字后加 `d` 或 `D`   |

> 各种数据类型默认值在内存中都表示`0`
>
> `boolean`和`char`是唯二的无符号类型

---

## 基本数据类型和引用数据类型区别

- **从概念方面来说**
  - 基本类型： 变量名指向具体的数据类型
  - 引用数据类型：变量名指向存储数据对象的内存地址
- **从内从方面来说**
  - 基本类型：变量在声明后，Java会立刻分配给他内存空间
  - 引用类型： 它以特殊的方式（类似C指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址
- **从使用方面来说**
  - 基本类型：使用时需要赋具体值，判断使用`==`号
  - 引用类型：使用时可以赋null,判断时使用`equals`方法

---

## 数据转换

### 自动转换（隐式转换）

Java中允许用户做有**限度**的类型转化。如果符合条件，Java将会自动做类型转换：

- **由小数据转换为大数据**

​		当目标类型的范围大于源类型的范围时，Java会自动执行**隐式类型转换**。

​		如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。

​		“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为**扩大转换**。

​		这些类型由“小”到“大”分别为：**(byte，short，char) < int < long < float < double。**

```java
int numInt = 10;
double numDouble = numInt; // 隐式将int转换为double
System.out.println(numDouble); // 输出结果为 10.0
```

---

> 注：
>
> 转换前后的数据类型要兼容，由于 **boolean 类型**只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。

- **整数类型和浮点类型进行计算后，结果会转为浮点类型。示例如下：**

```java
@Test
public void test(){
  int num = 20;
  float num1 = 5.5f;
  System.out.println("num/num1 = " + num / num1);
}
```

---

### 强制转换（显示转换）

显示类型转换：当目标类型的**范围**小于源类型的范围时，需要使用显式类型转换。显式类型转换需要使用**括号**将目标类型括起来，并在前面添加目标类型的名称。

> 强制类型转换使用括号（）
>
> 引用类型也可使用强制转换

示例：

```java
double numDouble = 10.5;
int numInt = (int) numDouble; // 显式将double转换为int
System.out.println(numInt); // 输出结果为 10
```

在上述示例中，浮点数类型的变量`numDouble`显式地转换为整数类型的变量`numInt`。注意，由于浮点数类型的范围大于整数类型的范围，所以转换时可能会导致精度丢失。

需要注意的是，当进行类型转换时，如果目标类型无法完全表示源类型的值，可能会发生数据溢出或精度丢失的情况，因此在进行类型转换时应谨慎处理。

---

## 装箱和拆箱

### 包装类

Java为每种基本数据类型都提供了对应的包装器类型，**让基本类型具备对象的特征**实现更多的功能。

| 基本数据类型 |  包装器类型   |
| :----------: | :-----------: |
|     byte     |     Byte      |
|    short     |     Short     |
|     int      |    Integer    |
|     long     |     Long      |
|    float     |     Float     |
|    double    |    Double     |
|     char     | **Character** |
|   boolean    |    Boolean    |

### 什么是装箱和拆箱

基本数据类型与包装类的转换被称为**装箱**和**拆箱**。

- **装箱**是将基本数据类型转换为引用数据类型。例如：`int` 转 `Integer`

> 装箱过程是通过调用包装类的 `valueOf` 方法实现的。

- **拆箱**是将引用数据类型转换为基本数据类型。例如：`Integer` 转 `int`

> 拆箱过程是通过调用包装类的 `xxxValue` 方法实现的。（xxx 代表对应的基本数据类型）。

---

### 自动装箱和自动拆箱

基本数据（Primitive）型的自动装箱（boxing）拆箱（unboxing）自 JDK 5 开始提供的功能。

自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。
因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。

```java
Integer i1 = 10; // 自动装箱
Integer i2 = new Integer(10); // 非自动装箱
Integer i3 = Integer.valueOf(10); // 非自动装箱
int i4 = new Integer(10); // 自动拆箱
int i5 = i2.intValue(); // 非自动拆箱
```

> Java 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式

- **拆箱装箱的应用场景**

  - 一种最普通的场景是：调用一个**含类型为 `Object` 参数的方法**，该 `Object` 可支持任意类型（因为 `Object` 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 `Integer` 装箱。

  - 另一种用法是：一个**非泛型的容器**，同样是为了保证通用，而将元素类型定义为 `Object`。于是，要将值类型数据加入容器时，需要装箱。

  - 当 `==` 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。

- **装箱、拆箱应用注意点**

  - 装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以**应该尽量避免装箱。**

  - 基础数据类型的比较操作使用 `==`，包装类的比较操作使用 `equals` 方法。

---

> Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别?
>
> 1.第一种方式不会触发自动装箱的过程；而第二种方式会触发；
>
> 2.在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。

